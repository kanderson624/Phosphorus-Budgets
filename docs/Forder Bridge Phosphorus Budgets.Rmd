---
title: "Phosphorus Budgets for FORB"
author: "Kenneth Anderson"
date: "2023-10-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("dplyr")
```

## ODNR Budgets: 

ODNR makes budgets for P reduction in potential wetlands using the following method: 

1. Put the lat/long of the outlet of the wetland into USGS Stream Stats to get the drainage area of the wetland (convert to acres)

2. Based on the size of the wetland correct for the amount of the drainage the wetland interacts with
  a. 0-99 acres: 95%
  b. 100-999 acres: 75%
  c. 1,000-9,999 acres: 25%
  d. 10,000-99,999 acres: 10%
  e. 100,000-999,999 acres: 1%
  f. 1,000,000 acres +: 0.5%

```{r}
# Drainage Area from Stream Stats
DA = 63
# Treated drainage area (corrected for drainage size)
tDA = if(DA <= 99){DA*0.95} else if(DA >= 100 & DA <= 999){DA*0.75} else if(DA >= 1000 & DA <= 9999){DA*0.25} else if(DA >= 10000 & DA <= 99999){DA*0.1} else if(DA >= 100000 & DA <= 999999){DA*0.01} else if(DA > 100000000){DA*0.005}
# units = acres
print(tDA)
```

3. Estimate P loading rate using the USGS SPARROW model (units are pounds P / year) based on total drainage area treated (calculated in step 2)

```{r}
# P Loading Rates for Ohio from USGS SPARROW:
# HUC-8 Drainage basin ID
HUC8 = c(4100001,4100008,4100009,4100010,4100011,4100003,4100005,5120101,5040006,5090202,4120200,4120101,4100007,4100006,5040001,5080001,5060001,4100014,4110001,4110002,4110003,4110004)
# Total phosphorus yield for each basin (kg/km^2/year)
TPyieldkgkm=c(75.2,131,129,83.9,140,114,106,293,206,216,0,123,152,114,134,201,209,149,179,249,245,109)
loading=data.frame(HUC8,TPyieldkgkm)
# correct to lbs/acre/year from kg/km^2/year:
corr=112.0850759
loading$TPyield = loading$TPyieldkgkm/corr

# select the HUC-8 basin that the wetland is a part of 
loadFORBHUC = loading$TPyield[loading$HUC8 == 4100005]
# multiply by the treated drainage area from step 2
loadFORB = loadFORBHUC * tDA
# units = lbs / year
print(loadFORB)
```

4. Estimate P removal based on literature (as proposed by TetraTech; units: pounds P/ acre / year): 
  a. Low estimate: 18% removal of P loading
  b. Hybrid estimate: 64% removal of P loading
  c. High estimate: 78% of P loading

```{r}
# P Removal Rates:
low = loadFORB*0.18
hybrid = loadFORB*0.64
high = loadFORB*0.78

# units = lbs/year
print(low)
print(hybrid)
print(high)
```

  
4b. For floodplain wetlands estimates are based on constants from Noe et al. 2019: 3.2 pounds P/ acre / year removal

### ***ASSUMPTIONS IN ODNR BUDGETS:*** 
  Not that many, but boy are they big assumptions<br>
  1. Drainage area is accurate (it's not)<br>
  2. SPARROW gives an accurate measurement of P loading<br>
  3. Literature estimates of loading are accurate <br>
  * Honestly this probably isn't the worst assumption if only because their estimates are so wide ranging.<br>
  4. Seasonal variation does not matter to whoever is looking for this budget. <br>
  5. Annual variation does not play a major role in phosphorus loading, or retention, or hydrologic dynamics.<br>

## Hybrid Modelling Budget 

Calculate phosphorus loading as above:

```{r}
# units = lbs / year
print(loadFORB)
```

Now we'll calculate the P retention at a couple locations across the wetland. <br>

We'll start with Wetland Complex 4:
```{r}
# Add in the P dataset (units here are mg/L for TP)
setwd("C:/Users/kande120/OneDrive - Kent State University/Phosphorus Budgets/FORB/Data")
Pdata<-read.csv("FORB P Budget Full inletsandoutlets.csv")
# subset out event sampling 
Pdata<- subset(Pdata, Sampling == "baseflow")
# Calculate percent retention in Wetland Complex 4
Pdata$retainedPcomp4=Pdata$Inlet_wetland_FORB_9-Pdata$Outlet_wetland_FORB_12
Pdata$percentPcomp4 = Pdata$retainedPcomp4 / Pdata$Inlet_wetland_FORB_9 * 100
percentRemoval = mean (Pdata$percentPcomp4,na.rm=T)
print(percentRemoval)
```
We get an average percent removal of 8.7% but see here how variable that is: 

```{r}
# make it realize it's a date time value
Pdata$Date <- as.Date(Pdata$Date, format="%m/%d/%Y")
# make the plot
library(ggplot2)
p1<-ggplot(data=Pdata, aes(x=Date, y=percentPcomp4)) +
  geom_bar(stat="identity")+scale_x_date(date_breaks = "1 month", date_labels =  "%b %Y")+theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
print(p1)
```

Now let's try out the whole flowpath, starting at the tile draining into Wetland Complex 4 and ending in the two streams that deposit into the Maumee:
```{r}
# take the average outflow between streams 1 and 2 (for samples at the end of the stream)
Pdata$outflowTP <- rowMeans(Pdata[c('Outlet_stream1_FORB_17_END', 'Outlet_stream2_FORB_18')], na.rm=TRUE)
# inflow remains largely the same for the main flowpath because the inlet tile is not sampled often
Pdata$inflowTP <- rowMeans(Pdata[c('Inlet_wetland_FORB_9', 'Inlet_tile_FORB_15')], na.rm=TRUE)

# Calculate percent retention in whole wetland
Pdata$retainedP=Pdata$inflowTP-Pdata$outflowTP
Pdata$percentP = Pdata$retainedP / Pdata$inflowTP * 100
percentRemoval = mean (Pdata$percentP,na.rm=T)
print(percentRemoval)
```
We want to still look at the variability of this measurement: 
```{r}
# make it realize it's a date time value
Pdata$Date <- as.Date(Pdata$Date, format="%m/%d/%Y")
# make the plot
library(ggplot2)
p2<-ggplot(data=Pdata, aes(x=Date, y=percentP)) +
  geom_bar(stat="identity")+scale_x_date(date_breaks = "1 month", date_labels =  "%b %Y")+theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
print(p2)
```

We see that the full wetland much more consistently retains P than just wetland complex 4. <br>

P retention at the wetland ranges from 19 to 83 % retention, but that doesn't account for seasonal differences so lets try to take annual averages: 

```{r}
# 2021
Pdata2021<- subset(Pdata, Year == "2021")
percentRemoval2021 = mean (Pdata2021$percentP,na.rm=T)
print(percentRemoval2021)
# 2022
Pdata2022<- subset(Pdata, Year == "2022")
percentRemoval2022 = mean (Pdata2022$percentP,na.rm=T)
print(percentRemoval2022)
# 2023
Pdata2023<- subset(Pdata, Year == "2023")
percentRemoval2023 = mean (Pdata2023$percentP,na.rm=T)
print(percentRemoval2023)
```
This gives us a range from 42% retention to 62% retention (but our data is not evenly distributed across different years) <br>

We can now apply these measurements of P retention to the estimated phosphorus loading from SPARROW modelling. 

```{r}
# units = lbs / year
print(loadFORB)

# P Removal Rates:
low = loadFORB*0.42
high = loadFORB*0.62

# units = lbs/year
print(low)
print(high)
```
By this budgetting we can estimate that Forder Bridge retains between 24 and 35 lbs P / year

### Rainfall at Ft. Wayne Budget
We'll use data from Ft. Wayne Indiana (31 miles away) downloaded from Weather Underground.<br>

We'll calculating runoff using the curve number of the soils: 
We will calculate the runoff that flows through the wetland during rain events based on some information about soil properties.


$$Q=\begin{cases}
0 \text{ for } P \le I_a\\
{(P-I_a)^2 \over P-I_a+S} \text{ for } P > I_a
\end{cases}$$

where: <br>
Q = runoff (inches)<br>
P = rainfall (inches)<br>
S = potential maximum soil moisture retention after runoff begins (inches)<br>
I_a = initial abstraction (inches; this is the amount of rainfall needed for runoff to occur)<br>



The runoff curve (CN) is used to calculate S
$$S = {1000 \over CN} -10$$
We will assume that: $$ I_a = 0.2S$$ as a standard correction. 
(See here https://onlinelibrary.wiley.com/doi/10.1111/j.1752-1688.2006.tb04481.x for discussion of whether that is a good correction but we're going to power through with it)


CN will depend on the soil of the site. In this case it's probably around 80, fairly poorly drained, but we may want to come back and think abit more about what our curve number should be. <br>

The drainage area we are using here accounts mainly for the drainage entering through the culvert which we expect the majority of to run through the wetland and out the stream into the Maumee river. The majority of this area is the field to the southeast of the FORB land parcel. 

```{r}
# Drainage Area calculated by DEM
tDA = 68.55
# convert tDA to m^2
tDAm2=tDA*4046.86
# units = m^2
print(tDAm2)
```

Then we import data on precipitation from weather underground at the Ft. Wayne weather station (31 miles away)

```{r}
setwd("C:/Users/kande120/OneDrive - Kent State University/Phosphorus Budgets/FORB/Data")
raindata<-read.csv("Ftwaynerainfall.csv")
# make it recognize that it's a date-time value
raindata = mutate(raindata, datetime = as.POSIXct(datetime, format = "%m/%d/%Y"))
# Rename so our old code keeps working 
dayrain=raindata
```
Then we calculate runoff as above.
```{r}
# Start out by calculating S (inches)
CN=85
S = (1000/CN)-10
# Calculate I (inches)
Ia = 0.2*S
# don't need to convert rain to inches/day, but lets name it so our old code still works
dayrain$precip = dayrain$precipaccum_in
# caculate runoff (inches) for each day in the dataset
dayrain$Q = ifelse(dayrain$precip<=Ia, 0, ((dayrain$precip-Ia)^2)/(dayrain$precip-Ia+S))
# scale up to the entire drainage area
dayrain$Q=tDAm2*dayrain$Q
# convert back to meters 
dayrain$Qm = dayrain$Q * 0.0254
# convert discharge to liters
dayrain$QL = dayrain$Qm * 1000
# Sum up data to get monthly values
library(lubridate)
library(tidyverse)
dayrain$Date=as.POSIXct(dayrain$datetime,format="%Y-%m-%d")
# Summarize the dataset by month and year
monthrain=dayrain %>% mutate(Month=month(Date,label = T),Year=year(Date)) %>%
  group_by(Year,Month) %>% summarise(QL=sum(QL,na.rm=T))
```

Now we add in the monthly measurements of Phosphorus concentrations to calculate P loading.
```{r}
# Add in the P dataset (units here are mg/L for TP)
setwd("C:/Users/kande120/OneDrive - Kent State University/Phosphorus Budgets/FORB/Data")
Pdata<-read.csv("FORB P Budget Full inletsandoutlets.csv")
# subset out event sampling 
Pdata<- subset(Pdata, Sampling == "baseflow")
# take the average outflow between streams 1 and 2 (for samples at the end of the stream)
Pdata$outflowTP <- rowMeans(Pdata[c('Outlet_stream1_FORB_17_END', 'Outlet_stream2_FORB_18')], na.rm=TRUE)
# Average the inflow between the main inlet tile and the start of complex 4 (the main inlet tile is not sampled as often as the start of complex 4)
Pdata$inflowTP <- rowMeans(Pdata[c('Inlet_wetland_FORB_9', 'Inlet_tile_FORB_15')], na.rm=TRUE)
# merge the datasets
total <- merge(Pdata,monthrain,by=c("Month","Year"),all=TRUE)
# Measure the mass of P entering the wetland (units = mg P/month)
total$Pin=total$inflowTP*total$QL
# calculate the total mass of P exiting the wetland (units = mg P/month)
total$Pout=total$outflowTP*total$QL
# Convert to lbs P/month
total$Pinlb=total$Pin/453592
total$Poutlb=total$Pout/453592
# calculate the amount of P removed
total$Premoved=total$Pinlb-total$Poutlb
```

Now we need to look at where we have data and attempt to extrapolate where we do not
```{r}
# To start lets look at just 2023
total23<- subset(total, Year == "2023")
total23<- subset(total23, select=c(Month,Year,Pinlb,Poutlb,Premoved,QL,inflowTP,outflowTP))
print(total23)
```

We can assume there is no P retained when there is no discharge: 
```{r}
library(dplyr)
# first make all NaNs into NAs
total23 <- total23 %>% mutate_all(~ifelse(is.nan(.), NA, .))
# now replace NAs where discharge = 0 as also 0
total23$Premoved=ifelse(test = total23$QL == 0, yes = "0", no = total23$Premoved)
```
We have one event with loading data but no retention data. Here we can estimate retention based on the average retention of the other months. 
```{r}
# tell r that Premoved is numeric: 
total23$Premoved=as.numeric(total23$Premoved)
# Calculate percent removal
total23$percentP=total23$Premoved/total23$Pinlb
percentRemoval = mean (total23$percentP,na.rm=T)
print(percentRemoval)
```
There's a pretty good amount of variation here, but lets power through and use the average. 
```{r}
# replace the month in question (July 2023)
total23$Premoved=ifelse(test = total23$Month == "Jul" & total23$Year == "2023", yes = total23$Pinlb*percentRemoval, no = total23$Premoved)
```

Now we can sum up the total P removed by the wetland over the course of the year: 
```{r}
Removal = sum (total23$Premoved,na.rm=T)
# This is the removal of P by pool by over the course of the 8 months that we have data for
print(Removal)
```
We can estimate the other 4 months by estimating a low and a high value for P loading and P retention. <br> 
We have discharge data for all months, so we don't want to just estimate loading, when we can estimate concentration instead:
```{r}
# our low estimate is the lowest concentration we saw: 
lowPcon = min(total23$inflowTP,na.rm = TRUE)
# our high estimate is the highest concentration we saw: 
highPcon= max(total23$inflowTP,na.rm = TRUE)

# then we can estimate the low end of % retention
lowPper = min(total23$percentP,na.rm = TRUE)
# and then the high end of % retention
highPper = max(total23$percentP,na.rm = TRUE)


# now calculate P load and retention using these concentrations to estimate the high and low end of P removal by the wetland:

# first for the low estimate
total23$Premovedlow=ifelse(test = is.na(total23$Premoved) , yes = total23$QL*lowPcon/453592*lowPper, no = total23$Premoved)
# then for the high estimate
total23$Premovedhigh=ifelse(test = is.na(total23$Premoved) , yes = total23$QL*highPcon/453592*highPper, no = total23$Premoved)

# Now we can sum up our full months: 
lowRemoval = sum (total23$Premovedlow,na.rm=T)
highRemoval = sum (total23$Premovedhigh,na.rm=T)
print(lowRemoval)
print(highRemoval)
```

 
### ***ASSUMPTIONS IN THIS BUDGET:*** 
  1. Drainage area is accurate (it's not)<br>
  2. Curve number is a good choice for this site <br>
  3. Groundwater dynamics are captured <br>
  4. Tile drains are accounted for (they're not) <br>
  5. Nearby rainfall data is accurate for the site <br>

## Lets try to account for the isolated pools: 

We're going to try and use depth data to estimate the mass of phosphorus in the water of each pool and assume that decreasing mass is a result of uptake (either into the sediment or via losses through groundwater).

For this we're going to need estimates of water volume and phosphorus concentrations at various points in time. 

We will use point measurements of depth to estimate water volume until we get some actual depth sensors in the pools. 

Point measurements of depth are NOT IDEAL. They are not measured in the same place and they are not consistent across the pool. WE CAN DO BETTER. But we need more/better data to do better and this is just a rough estimate. 
```{r}
# inputting area for each pool as estimated by Bob Midden using Acrobat's measure tool (units are in m2):
aforb1=911.46
aforb2=665.74
aforb3=773.41
aforb5=440.08
aforb6=460.15
aforb7=305.56
aforb8=661.46
```
We will compare this method to an estimate of inflow based on rainfall and assuming that all P that enters the pools stays in the pools because they are isolated wetlands.

```{r}
library(dplyr)
setwd("C:/Users/kande120/OneDrive - Kent State University/Phosphorus Budgets/FORB/Data")
Pdata<-read.csv("FORB_Samp master 12.19.csv")
# change all -999 values to NA
Pdata$tp_mgL=na_if(Pdata$tp_mgL, -999)
Pdata$samp_wdepth_cm=na_if(Pdata$samp_wdepth_cm, -999)
site1<- subset(Pdata, location == "FORB_01")
# calculate the volume in m^3
site1$volume = (site1$samp_wdepth_cm/100)*aforb1
# Convert to liters (*1000)
site1$volumeL=site1$volume * 1000
# calculate mass by multiplying concentration (mg/L) * liters = mg P
site1$Pmass = site1$volumeL * site1$tp_mgL
```

Lets plot this out for the first site to see what's happening: 
```{r}
library(ggplot2)
#convert datetime so R knows it's a date
site1$datetime=as.POSIXct(site1$datetime,format="%m/%d/%Y")
site1$datetime <- as.Date(site1$datetime, format="%Y-%m-%d")

# now plot it out
p1<-ggplot(data=site1, aes(x=datetime, y=Pmass)) +
  geom_bar(stat="identity",width=20)+scale_x_date(date_breaks = "1 month", date_labels =  "%b %Y")+theme_classic()+ylab("P mass in water (mg)")
print(p1)
```
So we're going to break this down into a minimum and maximum estimate of P being retained by these pools: 
Our highest value was January 2023: with over 40,000 mg of P in the pool. We know that at least this much P was in the pool at a given time and are assuming that there is not an outflow because these are isolated pools and that most P is retained. 

So even if the P is being agitated and recycled and isn't NEW there was at least this much P in the pool at any one point during the year. That is our minimum estimate of how much P is being retained by this pool. 
```{r}
# take the maximum value and convert to lbs to get the low end estimate of P retention
lowPpool1 = max(site1$Pmass,na.rm=TRUE)*2.20462e-6
lowPpool1
```
Our maximum estimate assumes that EACH P measurement corresponds to a rain event and that ALL P from that event is retained and that the pool dries out in between events. This is likely not the case, but it's our maximum where we are assuming that all the mass of P in our pool is being retained
```{r}
# take the sum of all P mass measurements to get the high end P retention in pool 1
highPpool1 = sum(site1$Pmass,na.rm=TRUE)*2.20462e-6
highPpool1
```
Now we can do the rest of the pools: 
```{r}
### Pool 2 ###
site6<- subset(Pdata, location == "FORB_02")
# calculate the volume in m^3
site6$volume = (site6$samp_wdepth_cm/100)*aforb2
# Convert to liters (*1000)
site6$volumeL=site6$volume * 1000
# calculate mass by multiplying concentration (mg/L) * liters = mg P
site6$Pmass = site6$volumeL * site6$tp_mgL
# calculate low end estimate
lowPpool2 = max(site6$Pmass,na.rm=TRUE)*2.20462e-6
# calculate high end estimate
highPpool2 = sum(site6$Pmass,na.rm=TRUE)*2.20462e-6

### Pool 3 ###
site3<- subset(Pdata, location == "FORB_03")
# calculate the volume in m^3
site3$volume = (site3$samp_wdepth_cm/100)*aforb3
# Convert to liters (*1000)
site3$volumeL=site3$volume * 1000
# calculate mass by multiplying concentration (mg/L) * liters = mg P
site3$Pmass = site3$volumeL * site3$tp_mgL
# calculate low end estimate
lowPpool3 = max(site3$Pmass,na.rm=TRUE)*2.20462e-6
# calculate high end estimate
highPpool3 = sum(site3$Pmass,na.rm=TRUE)*2.20462e-6

### Pool 5 ###
site5<- subset(Pdata, location == "FORB_05")
# calculate the volume in m^3
site5$volume = (site5$samp_wdepth_cm/100)*aforb5
# Convert to liters (*1000)
site5$volumeL=site5$volume * 1000
# calculate mass by multiplying concentration (mg/L) * liters = mg P
site5$Pmass = site5$volumeL * site5$tp_mgL
# calculate low end estimate
lowPpool5 = max(site5$Pmass,na.rm=TRUE)*2.20462e-6
# calculate high end estimate
highPpool5 = sum(site5$Pmass,na.rm=TRUE)*2.20462e-6

### Pool 6 ###
site6<- subset(Pdata, location == "FORB_06")
# calculate the volume in m^3
site6$volume = (site6$samp_wdepth_cm/100)*aforb6
# Convert to liters (*1000)
site6$volumeL=site6$volume * 1000
# calculate mass by multiplying concentration (mg/L) * liters = mg P
site6$Pmass = site6$volumeL * site6$tp_mgL
# calculate low end estimate
lowPpool6 = max(site6$Pmass,na.rm=TRUE)*2.20462e-6
# calculate high end estimate
highPpool6 = sum(site6$Pmass,na.rm=TRUE)*2.20462e-6

### Pool 7 ###
site7<- subset(Pdata, location == "FORB_07")
# calculate the volume in m^3
site7$volume = (site7$samp_wdepth_cm/100)*aforb7
# Convert to liters (*1000)
site7$volumeL=site7$volume * 1000
# calculate mass by multiplying concentration (mg/L) * liters = mg P
site7$Pmass = site7$volumeL * site7$tp_mgL
# calculate low end estimate
lowPpool7 = max(site7$Pmass,na.rm=TRUE)*2.20462e-6
# calculate high end estimate
highPpool7 = sum(site7$Pmass,na.rm=TRUE)*2.20462e-6

### Pool 8 ###
site8<- subset(Pdata, location == "FORB_08")
# calculate the volume in m^3
site8$volume = (site8$samp_wdepth_cm/100)*aforb8
# Convert to liters (*1000)
site8$volumeL=site8$volume * 1000
# calculate mass by multiplying concentration (mg/L) * liters = mg P
site8$Pmass = site8$volumeL * site8$tp_mgL
# calculate low end estimate (and covert to lbs at the same time)
lowPpool8 = max(site8$Pmass,na.rm=TRUE)*2.20462e-6
# calculate high end estimate (and covert to lbs at the same time)
highPpool8 = sum(site8$Pmass,na.rm=TRUE)*2.20462e-6
```

Now we can sum up all of those values to get an estimate of the low and high end retention for the isolated pools at FORB (excluding Wetland complex 2 which has never been observed to have water in it)

```{r}
# Wetland complex 1 
Comp1Plow = lowPpool1+lowPpool2+lowPpool3
Comp1Phigh = highPpool1+highPpool2+highPpool3
Comp1Plow
Comp1Phigh
# Wetland Complex 3
Comp3Plow = lowPpool5+lowPpool6+lowPpool7+lowPpool8
Comp3Phigh = highPpool5+highPpool6+highPpool7+highPpool8
Comp3Plow
Comp3Phigh


# Both complexes: 
IsoPlow = Comp1Plow + Comp3Plow
IsoPhigh = Comp1Phigh + Comp3Phigh
IsoPlow
IsoPhigh
```
### ***ASSUMPTIONS IN THIS BUDGET:*** 
  1. Volume estimates are accurate (they're not; measurements at staff guages or depth sensors will improve this)<br>
  2. Groundwater dynamics are captured <br>
  3. Measuring this at the monthly scale is sufficient to capture P dynamics at these sites. 
  
  
  


## Lets try a different method to account for these pools for comparison! 

In this new method our goal is to estimate the amount of water flowing into each wetland complex and then use average concentrations in the complex to estimate the amount of P entering the complex during the month that we estimate discharge into the pool. We think this estimate is much more dicey than the previous one but wanted to compare and look for ways that it could be useful because if we could improve this method it would solve the issue with the last one that we are relying on monthly data to capture phosphorus dynamics. <br>

We are using the full complexes as opposed to individual pools because there was a lot of overlap in terms of drainage area between the different pools

```{r}
# load in the rainfall data
setwd("C:/Users/kande120/OneDrive - Kent State University/Phosphorus Budgets/FORB/Data")
dayrain<-read.csv("Ftwaynerainfall.csv")
# make it recognize that it's a date-time value
dayrain = mutate(dayrain, datetime = as.POSIXct(datetime, format = "%m/%d/%Y"))
```

First we need to input the drainage area for each pool as measured by Bishwodeep with DEMs
```{r}
DAc1 = 10.00 # this is a placeholder number
DAc3 = 10.00 # this is a placeholder number

# convert tDA to m^2
DAc1m2=DAc1*4046.86
DAc3m2=DAc3*4046.86

```
We'll do the same thing as before and use pool 1 as an example before replicating for the whole batch. Basically the method for calculating runoff is the same as the budget using rainfall to estimate the main flow path (but with a much smaller drainage area).


```{r}
# Start out by calculating S (inches)
CN=85
S = (1000/CN)-10
# Calculate I (inches)
Ia = 0.2*S
# don't need to convert rain to inches/day, but lets name it so our old code still works
dayrain$precip = dayrain$precipaccum_in
# calculate runoff (inches) for each day in the dataset
dayrain$Q = ifelse(dayrain$precip<=Ia, 0, ((dayrain$precip-Ia)^2)/(dayrain$precip-Ia+S))
# scale up to the entire drainage area
dayrain$Q=DAc1m2*dayrain$Q
# convert back to meters 
dayrain$Qm = dayrain$Q * 0.0254
# convert discharge to liters
dayrain$QL = dayrain$Qm * 1000
# Sum up data to get monthly values
library(lubridate)
library(tidyverse)
dayrain$Date=as.POSIXct(dayrain$datetime,format="%Y-%m-%d")
# Summarize the dataset by month and year
monthrain=dayrain %>% mutate(Month=month(Date,label = T),Year=year(Date)) %>%
  group_by(Year,Month) %>% summarise(QL=sum(QL,na.rm=T))
```  
Now we're going to use the concentration in the pool at each month to estimate the amount of P entering the pool. This probably isn't a great estimate because the concentration in the pool is likely already somewhat diluted, OR is being loaded by what's already in the pool that is released when water enters it, but it might give us a decent estimate. Also not as great when comparing monthly concentrations to continuous rainfall data, but that problem likely isn't going to be solved unless we're able to find a relationship between P concentration and turbidity or something like that and then get sensors for turbidity in the pools. <br>

Regardless of whether or not this is a good metric of concentration it should give us a decent estimate of the amount of runoff (where the majority of P should be coming from) that is entering the pool.

```{r}
# bring in our P data
setwd("C:/Users/kande120/OneDrive - Kent State University/Phosphorus Budgets/FORB/Data")
Pdata<-read.csv("FORB_Samp master 12.19.csv")
# change all -999 values to NA
Pdata$tp_mgL=na_if(Pdata$tp_mgL, -999)
# make the date value usable
Pdata = mutate(Pdata, datetime = as.POSIXct(datetime, format = "%m/%d/%Y"))
Pdata$Date=as.POSIXct(Pdata$datetime,format="%Y-%m-%d")
# subset out complex 1 
site1<- subset(Pdata, location == "FORB_01" |location == "FORB_02" | location == "FORB_03" )
# Summarize the dataset by month and year (this takes the average of all values collected for each month between the different pools)
monthsite1=site1 %>% mutate(Month=month(Date,label = T),Year=year(Date)) %>%
  group_by(Year,Month) %>% summarise(tp_mgL=mean(tp_mgL,na.rm=T))
# merge the datasets
totalc1 <- merge(monthsite1,monthrain,by=c("Month","Year"),all=TRUE)
# convert NaNs to NAs
totalc1 <- totalc1 %>% mutate_all(~ifelse(is.nan(.), NA, .))
# calculate the amount of P entering the pool for each month! (units are mg) 
totalc1$massP <- totalc1$tp_mgL*totalc1$QL

## make high and low estimates for months with discharge but no concentration data
# our low estimate is the lowest concentration we saw: 
lowPcon1 = min(totalc1$tp_mgL,na.rm = TRUE)
# our high estimate is the highest concentration we saw: 
highPcon1= max(totalc1$tp_mgL,na.rm = TRUE)
# first for the low estimate
totalc1$Pmasslow1=ifelse(test = is.na(totalc1$massP) , yes = totalc1$QL*lowPcon1, no = totalc1$massP)
# then for the high estimate
totalc1$Pmasshigh1=ifelse(test = is.na(totalc1$massP) , yes = totalc1$QL*highPcon1, no = totalc1$massP)

# sum up the mass of P for the total retained by the pool (currently just 2023 because of the data included)
sum(totalc1$Pmasslow1,na.rm=T)*2.20462e-6
sum(totalc1$Pmasshigh1,na.rm=T)*2.20462e-6
```

Notes to self for refining this method: 
  add in multiple years precip data, take average of multiple years for estimating pool retention


Now we need to do all of this for wetland complex 3! Wetland complex 2 is always dry so we're not really sure what we could use as P concentrations for that one.  
```{r}
# calculate runoff (inches) again for each day in the dataset
dayrain$Q = ifelse(dayrain$precip<=Ia, 0, ((dayrain$precip-Ia)^2)/(dayrain$precip-Ia+S))
# scale up to the entire drainage area
dayrain$Q=DAc2m2*dayrain$Q
# convert back to meters 
dayrain$Qm = dayrain$Q * 0.0254
# convert discharge to liters
dayrain$QL = dayrain$Qm * 1000
# Sum up data to get monthly values
library(lubridate)
library(tidyverse)
dayrain$Date=as.POSIXct(dayrain$datetime,format="%Y-%m-%d")
# Summarize the dataset by month and year
monthrain=dayrain %>% mutate(Month=month(Date,label = T),Year=year(Date)) %>%
  group_by(Year,Month) %>% summarise(QL=sum(QL,na.rm=T))

# subset out complex 2
site2<- subset(Pdata, location == "FORB_05" |location == "FORB_06" | location == "FORB_07"|location == "FORB_08" )
# Summarize the dataset by month and year (this takes the average of all values collected for each month between the different pools)
monthsite2=site2 %>% mutate(Month=month(Date,label = T),Year=year(Date)) %>%
  group_by(Year,Month) %>% summarise(tp_mgL=mean(tp_mgL,na.rm=T))
# merge the datasets
totalc2 <- merge(monthsite2,monthrain,by=c("Month","Year"),all=TRUE)
# convert NaNs to NAs
totalc2 <- totalc2 %>% mutate_all(~ifelse(is.nan(.), NA, .))
# calculate the amount of P entering the pool for each month! (units are mg) 
totalc2$massP <- totalc2$tp_mgL*totalc2$QL

## make high and low estimates for months with discharge but no concentration data
# our low estimate is the lowest concentration we saw: 
lowPcon2 = min(totalc2$tp_mgL,na.rm = TRUE)
# our high estimate is the highest concentration we saw: 
highPcon2= max(totalc2$tp_mgL,na.rm = TRUE)
# first for the low estimate
totalc2$Pmasslow2=ifelse(test = is.na(totalc2$massP) , yes = totalc2$QL*lowPcon2, no = totalc2$massP)
# then for the high estimate
totalc2$Pmasshigh2=ifelse(test = is.na(totalc2$massP) , yes = totalc2$QL*highPcon2, no = totalc2$massP)

# sum up the mass of P for the total retained by the pool (currently just 2023 because of the data included)
sum(totalc2$Pmasslow2,na.rm=T)*2.20462e-6
sum(totalc2$Pmasshigh2,na.rm=T)*2.20462e-6
```
